---
/**
 * ================================================================================
 * HUB PAGE TEMPLATE — Interleaved Editorial Layout v3
 * ================================================================================
 * Purpose: Authority pages that define topics and link downward to spokes
 * 
 * KEY CHANGE: Prose sections and spoke cards are INTERLEAVED, not separated.
 * The layout splits markdown at H2 boundaries and inserts contextually-
 * relevant spoke cards after specific sections based on a per-hub mapping.
 *
 * Scroll rhythm: prose (white) → spoke cards (gray) → prose → cards → ...
 *
 * MONETIZATION: NEVER
 * ================================================================================
 */

import BaseLayout from './BaseLayout.astro';
import HubHero from '../components/HubHero.astro';
import SiblingNav from '../components/SiblingNav.astro';
import '@fontsource-variable/playfair-display/wght.css';
import { getCollection } from 'astro:content';

interface Props {
    title: string;
    description: string;
    topics?: string[];
    relatedPlaces?: string[];
    relatedRoutes?: string[];
    image?: string;
    imageAlt?: string;
    imageCredit?: string;
}

const { title, description, topics, relatedPlaces, relatedRoutes, image, imageAlt, imageCredit } = Astro.props;
const hubSlug = Astro.url.pathname.replace('/journeys/', '').replace(/\/$/, '');

// ── Collect all spoke content ──
const allPlaces = await getCollection('places', ({ data }) => 
    data.parentHub === hubSlug && !data.draft
);
const allRoutes = await getCollection('routes', ({ data }) => 
    data.parentHub === hubSlug && !data.draft
);
const allStories = await getCollection('stories', ({ data }) => !data.draft);
const allContext = await getCollection('context', ({ data }) => !data.draft);

const hubPlaceSlugs = allPlaces.map(p => p.slug);
const hubRouteSlugs = allRoutes.map(r => r.slug);

const relatedStories = allStories.filter(s => 
    s.data.relatedPlaces?.some((p: string) => hubPlaceSlugs.includes(p)) ||
    s.data.relatedRoutes?.some((r: string) => hubRouteSlugs.includes(r))
);
const relatedContext = allContext.filter(c => {
    const traditions = c.data.faithTraditions || [];
    const hubTopics = topics || [];
    return traditions.some((t: string) => hubTopics.includes(t.toLowerCase()));
});

const spokeCount = allPlaces.length + allRoutes.length + relatedStories.length + relatedContext.length;

// Build lookup maps by slug
const placeMap = Object.fromEntries(allPlaces.map(p => [p.slug, p]));
const routeMap = Object.fromEntries(allRoutes.map(r => [r.slug, r]));
const storyMap = Object.fromEntries(allStories.map(s => [s.slug, s]));
const contextMap = Object.fromEntries(allContext.map(c => [c.slug, c]));

// ── Spoke-to-Section Mapping ──
// After which H2 index (0-based) should which spokes appear?
// "afterH2" means: render these cards after the Nth H2 section.
// Slugs are resolved against placeMap/routeMap/storyMap/contextMap.
type SpokeRef = { type: 'place'|'route'|'story'|'context'; slug: string };
type SectionSpokes = { afterH2: number; items: SpokeRef[] };

const hubSpokeMap: Record<string, SectionSpokes[]> = {
    "buddhist-pilgrimage-paths": [
        { afterH2: 1, items: [ // After "The Four Great Sites"
            { type: 'place', slug: 'bodh-gaya' },
            { type: 'place', slug: 'lumbini' },
            { type: 'place', slug: 'sarnath' },
            { type: 'context', slug: 'four-sacred-sites-buddhism' },
        ]},
        { afterH2: 2, items: [ // After "Pilgrimage Circuits in East Asia"
            { type: 'place', slug: 'mount-koya' },
            { type: 'route', slug: 'shikoku-88-temples' },
            { type: 'route', slug: 'kumano-kodo' },
        ]},
        { afterH2: 3, items: [ // After "Circumambulation and Merit"
            { type: 'route', slug: 'kora-mount-kailash' },
        ]},
        { afterH2: 4, items: [ // After "Relics and Their Veneration"
            { type: 'story', slug: 'kobo-daishi-shikoku' },
            { type: 'story', slug: 'xuanzang-buddhist-pilgrim' },
            { type: 'context', slug: 'relics-and-sacred-objects' },
        ]},
        { afterH2: 5, items: [ // After "Modern Buddhist Pilgrimage"
            { type: 'context', slug: 'pilgrimage-tourism-modern-era' },
            { type: 'context', slug: 'psychology-of-pilgrimage' },
            { type: 'context', slug: 'what-is-pilgrimage' },
            { type: 'context', slug: 'women-and-pilgrimage' },
        ]},
    ],
    "christian-pilgrimage-traditions": [
        { afterH2: 1, items: [ // After "Origins in the Early Church"
            { type: 'place', slug: 'jerusalem-old-city' },
            { type: 'story', slug: 'helena-and-the-true-cross' },
            { type: 'story', slug: 'egeria-first-pilgrim-writer' },
            { type: 'context', slug: 'history-of-christian-pilgrimage' },
        ]},
        { afterH2: 2, items: [ // After "The Medieval Flowering"
            { type: 'place', slug: 'rome-vatican' },
            { type: 'route', slug: 'via-francigena' },
            { type: 'story', slug: 'legend-of-saint-james' },
            { type: 'story', slug: 'margery-kempe-medieval-pilgrim' },
        ]},
        { afterH2: 3, items: [ // After "Reformation & Responses"
            { type: 'place', slug: 'lourdes' },
            { type: 'route', slug: 'st-olavs-way' },
        ]},
        { afterH2: 4, items: [ // After "Modern Transformations"
            { type: 'context', slug: 'pilgrimage-tourism-modern-era' },
            { type: 'context', slug: 'psychology-of-pilgrimage' },
            { type: 'context', slug: 'women-and-pilgrimage' },
        ]},
    ],
    "faith-based-journeys": [
        { afterH2: 1, items: [ // After "Why Humans Undertake Pilgrimages"
            { type: 'context', slug: 'what-is-pilgrimage' },
            { type: 'context', slug: 'psychology-of-pilgrimage' },
        ]},
        { afterH2: 2, items: [ // After "Sacred Places and the Meaning of Destination"
            { type: 'place', slug: 'jerusalem' },
            { type: 'place', slug: 'santiago-de-compostela' },
            { type: 'place', slug: 'varanasi' },
        ]},
        { afterH2: 3, items: [ // After "Routes, Travel, and Movement"
            { type: 'route', slug: 'camino-de-santiago' },
            { type: 'route', slug: 'abraham-path' },
        ]},
        { afterH2: 4, items: [ // After "Community, Tradition, and Shared Memory"
            { type: 'context', slug: 'women-and-pilgrimage' },
            { type: 'context', slug: 'relics-and-sacred-objects' },
        ]},
        { afterH2: 5, items: [ // After "Pilgrimage in the Modern World"
            { type: 'context', slug: 'pilgrimage-tourism-modern-era' },
        ]},
    ],
    "islamic-pilgrimage-traditions": [
        { afterH2: 0, items: [ // After "The Hajj: Pilgrimage as Pillar of Faith"
            { type: 'place', slug: 'mecca' },
            { type: 'context', slug: 'five-pillars-hajj-explained' },
        ]},
        { afterH2: 1, items: [ // After "The Rituals of Hajj"
            { type: 'route', slug: 'hajj-route' },
        ]},
        { afterH2: 2, items: [ // After "Umrah: The Lesser Pilgrimage"
            { type: 'route', slug: 'umrah' },
        ]},
        { afterH2: 3, items: [ // After "Ziyarat: Visiting Sacred Sites"
            { type: 'place', slug: 'medina' },
            { type: 'place', slug: 'najaf-karbala' },
            { type: 'context', slug: 'ziyarat-visiting-shrines-islam' },
        ]},
        { afterH2: 4, items: [ // After "Jerusalem in Islamic Pilgrimage"
            { type: 'place', slug: 'dome-of-the-rock' },
            { type: 'place', slug: 'al-aqsa-mosque' },
        ]},
        { afterH2: 5, items: [ // After "Historical Development and Modern Practice"
            { type: 'story', slug: 'ibn-battuta-pilgrim-traveler' },
            { type: 'context', slug: 'pilgrimage-tourism-modern-era' },
        ]},
    ],
    "jewish-pilgrimage-heritage": [
        { afterH2: 0, items: [ // After "Pilgrimage and the Temple"
            { type: 'place', slug: 'western-wall' },
            { type: 'context', slug: 'three-pilgrim-festivals-judaism' },
            { type: 'context', slug: 'aliyah-leregel' },
        ]},
        { afterH2: 2, items: [ // After "Sacred Sites Beyond Jerusalem"
            { type: 'place', slug: 'hebron-cave-patriarchs' },
            { type: 'place', slug: 'rachels-tomb' },
            { type: 'place', slug: 'safed-kabbalah' },
            { type: 'place', slug: 'mount-meron' },
        ]},
        { afterH2: 3, items: [ // After "The Concept of Aliyah and Return"
            { type: 'route', slug: 'temple-mount-ascent' },
            { type: 'story', slug: 'rabbi-nachman-journey-to-israel' },
        ]},
        { afterH2: 4, items: [ // After "Diaspora Pilgrimage Traditions"
            { type: 'context', slug: 'diaspora-pilgrimage' },
        ]},
    ],
};

// Resolve the mapping for this hub
const sectionSpokes = hubSpokeMap[hubSlug] || [];
const spokesByH2: Record<number, SpokeRef[]> = {};
for (const ss of sectionSpokes) {
    spokesByH2[ss.afterH2] = ss.items;
}

// Helper to resolve a SpokeRef to actual data
function resolveSpoke(ref: SpokeRef) {
    if (ref.type === 'place') {
        const p = placeMap[ref.slug];
        if (!p) return null;
        return { type: 'place', slug: ref.slug, title: p.data.title, desc: p.data.description, meta: `${p.data.region}, ${p.data.country}`, url: `/places/${ref.slug}` };
    }
    if (ref.type === 'route') {
        const r = routeMap[ref.slug];
        if (!r) return null;
        const meta = [r.data.distanceKm ? `${r.data.distanceKm} km` : '', r.data.difficulty || ''].filter(Boolean).join(' · ');
        return { type: 'route', slug: ref.slug, title: r.data.title, desc: r.data.description, meta, url: `/routes/${ref.slug}` };
    }
    if (ref.type === 'story') {
        const s = storyMap[ref.slug];
        if (!s) return null;
        return { type: 'story', slug: ref.slug, title: s.data.title, desc: s.data.description, meta: 'Story', url: `/stories/${ref.slug}` };
    }
    if (ref.type === 'context') {
        const c = contextMap[ref.slug];
        if (!c) return null;
        return { type: 'context', slug: ref.slug, title: c.data.title, desc: c.data.description, meta: 'Context', url: `/context/${ref.slug}` };
    }
    return null;
}

// H2 indices to SKIP from prose (self-referential filler sections)
const skipH2: Record<string, number[]> = {
    "buddhist-pilgrimage-paths": [6],   // "Exploring Buddhist Pilgrimage on This Site"
    "faith-based-journeys": [6],         // "How This Site Approaches Faith-Based Journeys"
    "islamic-pilgrimage-traditions": [6], // "Exploring Islamic Pilgrimage on This Site"
    "jewish-pilgrimage-heritage": [7],   // "Exploring Jewish Pilgrimage on This Site"
};
const skipIndices = skipH2[hubSlug] || [];

// Sibling hubs
const allHubs = await getCollection('hubs', ({ data }) => !data.draft);
const siblingHubs = allHubs.filter(h => h.slug !== hubSlug);
---
<BaseLayout 
    title={title} 
    description={description}
    breadcrumbs={[
        { name: 'Home', url: '/' },
        { name: 'Journeys', url: '/journeys' },
        { name: title, url: Astro.url.pathname }
    ]}
    schema={{
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": title,
        "description": description,
        "url": `https://diggingscriptures.com${Astro.url.pathname}`,
        "publisher": {
            "@type": "Organization",
            "name": "Digging Scriptures"
        }
    }}
>

<!-- ═══════════════════ READING PROGRESS BAR ═══════════════════ -->
<div class="progress-bar" id="progress-bar"></div>

<!-- ═══════════════════ HERO ═══════════════════ -->
<HubHero
    image={image}
    imageAlt={imageAlt}
    badge="Pilgrimage Tradition"
    title={title}
    description={description}
    stats={[
        { label: `${spokeCount} related articles` },
        { label: `${allPlaces.length} places` },
        { label: `${allRoutes.length} routes` },
    ]}
/>

<!-- ═══════════════════ MOBILE TOC ═══════════════════ -->
<div class="mobile-toc-wrapper container" id="mobile-toc">
    <button class="mobile-toc-toggle" id="mobile-toc-toggle" aria-expanded="false">
        <span>Table of contents</span>
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="mobile-toc-chevron">
            <path d="M4 6l4 4 4-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
    </button>
    <nav class="mobile-toc-nav" id="mobile-toc-nav" aria-label="Table of contents (mobile)">
        <div id="mobile-toc-links"></div>
    </nav>
</div>

<!-- ═══════════════════ INTERLEAVED CONTENT ═══════════════════ -->
<article class="hub-article">
    <div class="container">
        <div class="hub-layout">

            <!-- ═══════════════ SIDEBAR TOC (desktop) ═══════════════ -->
            <aside class="hub-toc-wrapper" id="hub-toc">
                <nav class="hub-toc" aria-label="Table of contents">
                    <p class="hub-toc-label">In this article</p>
                    <div class="hub-toc-links" id="toc-links"></div>
                </nav>
            </aside>

            <!-- ═══════════════ MAIN CONTENT (prose + inline spokes) ═══════════════ -->
            <div class="hub-content" id="hub-content">
                <section class="content" id="hub-prose">
                    <slot />
                </section>
            </div>
        </div>
    </div>
</article>

<!-- ═══════════════════ INLINE SPOKE CARD TEMPLATES (hidden, used by JS) ═══════════════════ -->
<template id="spoke-break-template">
    <div class="hub-spoke-break">
        <div class="hub-spoke-break-inner"></div>
    </div>
</template>

<!-- Spoke data for JS interleaving -->
<script id="spoke-data" type="application/json" set:html={JSON.stringify({
    spokesByH2,
    skipIndices,
    resolved: Object.fromEntries(
        Object.entries(spokesByH2).map(([h2idx, refs]) => [
            h2idx,
            (refs as SpokeRef[]).map(resolveSpoke).filter(Boolean)
        ])
    )
})} />

<!-- ═══════════════════ SIBLING HUBS ═══════════════════ -->
<SiblingNav
    label="Also explore"
    basePath="/journeys"
    items={siblingHubs.map(h => ({ slug: h.slug, title: h.data.title, description: h.data.description }))}
/>

</BaseLayout>

<!-- ═══════════════════ SCRIPTS ═══════════════════ -->
<script>
document.addEventListener('DOMContentLoaded', () => {
    // ── Reading progress bar ──
    const bar = document.getElementById('progress-bar');
    if (bar) {
        window.addEventListener('scroll', () => {
            const h = document.documentElement.scrollHeight - window.innerHeight;
            bar.style.width = h > 0 ? `${(window.scrollY / h) * 100}%` : '0%';
        }, { passive: true });
    }

    // ── Parse spoke data ──
    const dataEl = document.getElementById('spoke-data');
    if (!dataEl) return;
    const { resolved, skipIndices } = JSON.parse(dataEl.textContent || '{}');

    // ── Interleave spoke cards into prose ──
    const prose = document.getElementById('hub-prose');
    if (!prose) return;
    
    const headings = Array.from(prose.querySelectorAll('h2'));
    
    // Remove filler sections (work backwards to preserve indices)
    const sortedSkips = [...(skipIndices || [])].sort((a, b) => b - a);
    for (const idx of sortedSkips) {
        const h2 = headings[idx];
        if (!h2) continue;
        // Remove everything from this H2 to the next H2 or end
        let node = h2;
        const toRemove = [node];
        while (node.nextElementSibling && node.nextElementSibling.tagName !== 'H2') {
            toRemove.push(node.nextElementSibling);
            node = node.nextElementSibling;
        }
        toRemove.forEach(n => n.remove());
        headings.splice(idx, 1);
    }

    // Insert spoke breaks after each mapped H2
    for (const [h2IdxStr, spokes] of Object.entries(resolved)) {
        const h2Idx = parseInt(h2IdxStr);
        const h2 = headings[h2Idx];
        if (!h2 || !spokes || spokes.length === 0) continue;

        // Find the end of this section (next H2 or end of prose)
        let insertAfter = h2;
        let sibling = h2.nextElementSibling;
        while (sibling && sibling.tagName !== 'H2') {
            insertAfter = sibling;
            sibling = sibling.nextElementSibling;
        }

        // Build the spoke break
        const breakDiv = document.createElement('div');
        breakDiv.className = 'hub-spoke-break';
        
        const grid = document.createElement('div');
        grid.className = 'hub-spoke-break-grid';

        for (const spoke of spokes) {
            const card = document.createElement('a');
            card.href = spoke.url;
            card.className = 'hub-inline-card';

            const typeLabel = spoke.type === 'place' ? 'Sacred Place' 
                : spoke.type === 'route' ? 'Pilgrimage Route'
                : spoke.type === 'story' ? 'Story' : 'Context';
            
            card.innerHTML = `
                <span class="hub-inline-card-type">${typeLabel}</span>
                <span class="hub-inline-card-title">${spoke.title}</span>
                <span class="hub-inline-card-desc">${spoke.desc || ''}</span>
                <span class="hub-inline-card-arrow">→</span>
            `;
            grid.appendChild(card);
        }

        breakDiv.appendChild(grid);
        insertAfter.after(breakDiv);
    }

    // ── TOC generation (desktop + mobile) ──
    // Re-query headings after removals
    const finalHeadings = prose.querySelectorAll('h2');
    const tocDesktop = document.getElementById('toc-links');
    const tocMobile = document.getElementById('mobile-toc-links');

    if (finalHeadings.length === 0) {
        const w = document.getElementById('hub-toc');
        const m = document.getElementById('mobile-toc');
        if (w) w.style.display = 'none';
        if (m) m.style.display = 'none';
        return;
    }

    finalHeadings.forEach((h, i) => {
        const id = h.id || `section-${i}`;
        h.id = id;
        [tocDesktop, tocMobile].forEach(container => {
            if (!container) return;
            const a = document.createElement('a');
            a.href = `#${id}`;
            a.textContent = h.textContent || '';
            a.className = 'hub-toc-link';
            container.appendChild(a);
        });
    });

    // Scroll spy (desktop)
    if (tocDesktop) {
        const links = tocDesktop.querySelectorAll('.hub-toc-link');
        const obs = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    links.forEach(l => l.classList.remove('active'));
                    const a = tocDesktop.querySelector(`a[href="#${entry.target.id}"]`);
                    if (a) a.classList.add('active');
                }
            });
        }, { rootMargin: '-20% 0px -70% 0px' });
        finalHeadings.forEach(h => obs.observe(h));
    }

    // Mobile TOC toggle
    const toggleBtn = document.getElementById('mobile-toc-toggle');
    const mobileNav = document.getElementById('mobile-toc-nav');
    if (toggleBtn && mobileNav) {
        toggleBtn.addEventListener('click', () => {
            const open = toggleBtn.getAttribute('aria-expanded') === 'true';
            toggleBtn.setAttribute('aria-expanded', String(!open));
            mobileNav.classList.toggle('open');
        });
        mobileNav.querySelectorAll('a').forEach(a => {
            a.addEventListener('click', () => {
                toggleBtn.setAttribute('aria-expanded', 'false');
                mobileNav.classList.remove('open');
            });
        });
    }
});
</script>
